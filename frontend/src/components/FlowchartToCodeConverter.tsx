'use client'

import React, { useState, useCallback, useEffect } from 'react'
import Button from './Button'
import { executeCode, ExecuteResponse } from '../utils/api'

interface FlowchartNode {
  id: number
  x: number
  y: number
  type: 'circle' | 'square' | 'triangle' | 'diamond' | 'hexagon' | 'parallelogram'
  label?: string
  meta?: {
    role?: string
    group?: string
    inputs?: string[]
    outputs?: string[]
  }
}

interface FlowchartEdge {
  from: number
  to: number
  label?: string
}

interface FlowchartToCodeConverterProps {
  nodes: FlowchartNode[]
  edges: FlowchartEdge[]
  autoGenerate?: boolean
}

/**
 * Converts flowchart nodes and edges to executable Cubit code
 * This is the REAL flowchart-to-code conversion implementation
 */
export default function FlowchartToCodeConverter({ 
  nodes, 
  edges, 
  autoGenerate = false 
}: FlowchartToCodeConverterProps) {
  const [generatedCode, setGeneratedCode] = useState<string>('')
  const [output, setOutput] = useState<ExecuteResponse | null>(null)
  const [loading, setLoading] = useState(false)

  /**
   * Generate Cubit code from flowchart structure
   */
  const generateCode = useCallback(() => {
    if (nodes.length === 0) {
      setGeneratedCode('# No flowchart nodes to convert\n# Add nodes to the flowchart above to generate code')
      return
    }

    const codeLines: string[] = []
    codeLines.push('# Auto-generated from flowchart')
    codeLines.push('# Generated by Cubit Visual Flowchart Editor')
    codeLines.push('')

    // Track which nodes we've processed to avoid duplicates
    const processedNodes = new Set<number>()
    
    // Find all variables from node metadata
    const variables = new Set<string>()
    nodes.forEach(node => {
      if (node.meta?.inputs) {
        node.meta.inputs.forEach(input => {
          const varName = input.split(':')[0].trim()
          if (varName) variables.add(varName)
        })
      }
      if (node.meta?.outputs) {
        node.meta.outputs.forEach(output => {
          const varName = output.split(':')[0].trim()
          if (varName) variables.add(varName)
        })
      }
    })

    // Initialize variables
    if (variables.size > 0) {
      codeLines.push('# Variable initialization')
      Array.from(variables).forEach(varName => {
        codeLines.push(`let ${varName} = 0`)
      })
      codeLines.push('')
    }

    // Start from the first node (or find a designated start node)
    const startNode = nodes[0]
    
    /**
     * Recursively generate code for a node and its descendants
     */
    const generateNodeCode = (nodeId: number, indent: string = ''): void => {
      if (processedNodes.has(nodeId)) return
      processedNodes.add(nodeId)

      const node = nodes.find(n => n.id === nodeId)
      if (!node) return

      const outgoingEdges = edges.filter(e => e.from === nodeId)

      switch (node.type) {
        case 'circle': {
          // Circle = Loop (while)
          codeLines.push(`${indent}# Loop: ${node.label || 'condition'}`)
          if (node.label) {
            codeLines.push(`${indent}while ${node.label} {`)
            // Process edges inside the loop
            outgoingEdges.forEach(edge => {
              generateNodeCode(edge.to, indent + '  ')
            })
            codeLines.push(`${indent}}`)
          } else {
            codeLines.push(`${indent}# Note: Add a condition label to this loop node`)
            outgoingEdges.forEach(edge => {
              generateNodeCode(edge.to, indent)
            })
          }
          break
        }

        case 'square': {
          // Square = Conditional (if/else)
          codeLines.push(`${indent}# Conditional: ${node.label || 'condition'}`)
          if (node.label) {
            codeLines.push(`${indent}if ${node.label} {`)
            
            // Find true/false branches
            const trueBranch = outgoingEdges.find(e => 
              e.label?.toLowerCase() === 'true' || e.label?.toLowerCase() === 't'
            )
            const falseBranch = outgoingEdges.find(e => 
              e.label?.toLowerCase() === 'false' || e.label?.toLowerCase() === 'f'
            )
            const unlabeledEdges = outgoingEdges.filter(e => 
              !e.label || (e.label.toLowerCase() !== 'true' && 
                          e.label.toLowerCase() !== 't' && 
                          e.label.toLowerCase() !== 'false' && 
                          e.label.toLowerCase() !== 'f')
            )

            if (trueBranch) {
              generateNodeCode(trueBranch.to, indent + '  ')
            }

            if (falseBranch) {
              codeLines.push(`${indent}} else {`)
              generateNodeCode(falseBranch.to, indent + '  ')
            }

            codeLines.push(`${indent}}`)

            // Process any unlabeled edges after the if/else
            unlabeledEdges.forEach(edge => {
              generateNodeCode(edge.to, indent)
            })
          } else {
            codeLines.push(`${indent}# Note: Add a condition label to this conditional node`)
            outgoingEdges.forEach(edge => {
              generateNodeCode(edge.to, indent)
            })
          }
          break
        }

        case 'triangle': {
          // Triangle = Function call / Print
          codeLines.push(`${indent}# Function/Output: ${node.label || 'action'}`)
          if (node.label) {
            // Check if it looks like a function call or just text
            if (node.label.includes('(') || /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(node.label)) {
              codeLines.push(`${indent}${node.label}`)
            } else {
              codeLines.push(`${indent}print "${node.label}"`)
            }
          }
          outgoingEdges.forEach(edge => {
            generateNodeCode(edge.to, indent)
          })
          break
        }

        case 'diamond': {
          // Diamond = Assignment / Decision
          codeLines.push(`${indent}# Assignment: ${node.label || 'variable = value'}`)
          if (node.label) {
            codeLines.push(`${indent}${node.label}`)
          }
          outgoingEdges.forEach(edge => {
            generateNodeCode(edge.to, indent)
          })
          break
        }

        case 'hexagon': {
          // Hexagon = Variable definition
          codeLines.push(`${indent}# Variable: ${node.label || 'varname'}`)
          if (node.label) {
            // Check if it's an assignment or just a declaration
            if (node.label.includes('=')) {
              codeLines.push(`${indent}let ${node.label}`)
            } else {
              codeLines.push(`${indent}let ${node.label} = 0`)
            }
          }
          outgoingEdges.forEach(edge => {
            generateNodeCode(edge.to, indent)
          })
          break
        }

        case 'parallelogram': {
          // Parallelogram = Input/Output
          codeLines.push(`${indent}# I/O: ${node.label || 'output'}`)
          if (node.label) {
            codeLines.push(`${indent}print ${node.label}`)
          }
          outgoingEdges.forEach(edge => {
            generateNodeCode(edge.to, indent)
          })
          break
        }

        default: {
          outgoingEdges.forEach(edge => {
            generateNodeCode(edge.to, indent)
          })
        }
      }
    }

    if (startNode) {
      generateNodeCode(startNode.id)
    }

    codeLines.push('')
    codeLines.push('# End of generated code')

    const code = codeLines.join('\n')
    setGeneratedCode(code)
  }, [nodes, edges])

  // Auto-generate when nodes/edges change if autoGenerate is true
  useEffect(() => {
    if (autoGenerate && nodes.length > 0) {
      generateCode()
    }
  }, [nodes, edges, autoGenerate, generateCode])

  /**
   * Execute the generated code
   */
  const executeGeneratedCode = async () => {
    if (!generatedCode.trim()) {
      setOutput({
        output: null,
        result: null,
        error: 'No code to execute. Generate code from the flowchart first.'
      })
      return
    }

    setLoading(true)
    setOutput(null)

    try {
      const result = await executeCode({
        code: generatedCode,
        teaching_enabled: false
      })
      setOutput(result)
    } catch (error) {
      setOutput({
        output: null,
        result: null,
        error: error instanceof Error ? error.message : 'Unknown error'
      })
    } finally {
      setLoading(false)
    }
  }

  /**
   * Copy generated code to clipboard
   */
  const copyCode = () => {
    navigator.clipboard.writeText(generatedCode).then(() => {
      // Could show a toast here
    })
  }

  return (
    <div className="space-y-4">
      {/* Code Generation Section */}
      <div className="bg-[var(--color-surface)] border border-[rgba(255,255,255,0.12)] rounded-lg p-4">
        <div className="flex items-center justify-between mb-3">
          <h3 className="text-lg font-semibold">Generated Cubit Code</h3>
          <div className="flex gap-2">
            <Button
              variant="secondary"
              onClick={generateCode}
              className="text-sm"
            >
              üîÑ Generate Code
            </Button>
            <Button
              variant="secondary"
              onClick={copyCode}
              disabled={!generatedCode.trim()}
              className="text-sm"
            >
              üìã Copy
            </Button>
            <Button
              variant="primary"
              onClick={executeGeneratedCode}
              disabled={loading || !generatedCode.trim()}
              className="text-sm"
            >
              {loading ? '‚è≥ Running...' : '‚ñ∂Ô∏è Execute'}
            </Button>
          </div>
        </div>

        {/* Generated Code Display */}
        <div className="bg-[var(--color-bg)] border border-[rgba(255,255,255,0.12)] rounded-lg p-4 max-h-96 overflow-auto">
          <pre className="text-sm font-mono text-white whitespace-pre-wrap">
            {generatedCode || '// Click "Generate Code" to convert your flowchart to Cubit code\n// Or enable auto-generate to see live updates'}
          </pre>
        </div>
      </div>

      {/* Execution Output */}
      {output && (
        <div className="bg-[var(--color-surface)] border border-[rgba(255,255,255,0.12)] rounded-lg p-4">
          <h4 className="text-sm font-semibold mb-3">Execution Output</h4>

          {output.output && (
            <div className="mb-3">
              <div className="text-xs text-[var(--color-muted)] mb-1">Output:</div>
              <div className="bg-[var(--color-bg)] rounded-lg p-3">
                <pre className="text-sm text-white whitespace-pre-wrap font-mono">
                  {output.output}
                </pre>
              </div>
            </div>
          )}

          {output.result !== null && output.result !== undefined && (
            <div className="mb-3">
              <div className="text-xs text-[var(--color-muted)] mb-1">Result:</div>
              <div className="bg-[var(--color-bg)] rounded-lg p-3">
                <pre className="text-sm text-[var(--color-accent)] font-mono">
                  {JSON.stringify(output.result, null, 2)}
                </pre>
              </div>
            </div>
          )}

          {output.error && (
            <div className="bg-red-900/20 border border-red-500/50 rounded-lg p-3">
              <div className="text-xs text-red-300 mb-1">Error:</div>
              <pre className="text-sm text-red-400 whitespace-pre-wrap font-mono">
                {output.error}
              </pre>
            </div>
          )}

          {!output.output && !output.result && !output.error && (
            <div className="bg-green-900/20 border border-green-500/50 rounded-lg p-3 text-center">
              <div className="text-sm text-green-300">
                ‚úì Code executed successfully
              </div>
            </div>
          )}
        </div>
      )}

      {/* Help Section */}
      <div className="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
        <h4 className="text-sm font-semibold text-blue-300 mb-2">üí° Code Generation Tips</h4>
        <ul className="text-sm text-blue-200 space-y-1">
          <li>‚Ä¢ <strong>Circle nodes</strong>: Add a condition label (e.g., "x &lt; 10") to create while loops</li>
          <li>‚Ä¢ <strong>Square nodes</strong>: Label with condition, then label outgoing edges as "true" or "false"</li>
          <li>‚Ä¢ <strong>Triangle nodes</strong>: Use for function calls or print statements</li>
          <li>‚Ä¢ <strong>Diamond nodes</strong>: Use for assignments (e.g., "x = x + 1")</li>
          <li>‚Ä¢ <strong>Hexagon nodes</strong>: Use for variable declarations</li>
          <li>‚Ä¢ <strong>Parallelogram nodes</strong>: Use for print/output operations</li>
        </ul>
      </div>
    </div>
  )
}
